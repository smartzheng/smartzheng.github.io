<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on smartzheng</title>
    <link>https://smartzheng.github.io/posts/</link>
    <description>Recent content in Posts on smartzheng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 31 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://smartzheng.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java并发：多线程安全总结</title>
      <link>https://smartzheng.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</guid>
      <description>###1.并发基础
定义：一个cpu“同时”处理多个任务，而多个线程都在争取这个cpu资源
####1.1 优点
 充分发挥多核CPU的计算能力
 方便进行业务拆分，提升应用性能  ####1.2 缺点
 频繁切换上下文耗时
 线程安全问题：原子性、有序性、重排序  ####1.3 相关概念
 同步、异步：分别在于是否被调用的方法结束后，调用者后面的代码才能执行 并发、并行：前者指一个cpu通过切换时间片“同时”处理多个任务；后者指真正意义上的同时进行，需要多个CPU 阻塞、非阻塞：如果一个线程占用了临界资源，那么其他线程只有等待该资源释放方可继续执行，此时等待的线程被挂起，即阻塞；非阻塞相反，强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行 临界区：表示一种可以被多个线程使用公共资源或者共享数据，当一个线程占用时其他线程必须等待  ###2.线程基础 ####2.1 创建线程的方式
 继承Thread，重新run方法（局限：只能单继承） 实现Runable，传给Thread 实现callable，submit到线程池  ####2.2 线程的状态
 NEW 初识状态，被创建但未start() RUNNABLE 运行状态（实际上在系统调度情况下可以分为RUNNING和READY状态） BLOCKED 阻塞状态，线程阻塞于锁 WAITING 等待转态，等待其他线程通知或中断 TIMED_WAITING 超时等待，当超时等待时间到达后，线程会切换到Runable的状态 TERMINATED 终止状态，线程执行完毕  ####2.3 线程状态基本操作
2.3.1 stop
 暴力停止，已被废弃
  2.3.2 interrupt / isInterrupted / interrupted
 interrupt：中断该线程对象，如果该线程调用了wait()/wait(long)/sleep()/sleep(long)/join()/join(long)方法时会抛出InterruptedException并清除标志位（线程的中断可以理解为一个标志位，表示一个运行中的线程是否被其他线程中断） isInterrupted：判断该线程是否被中断，不会清除标志位
 interrupted：判断该线程是否被中断，会清除标志位
  2.3.3 join</description>
    </item>
    
    <item>
      <title>Navigation返回Fragment重走onCreateView问题</title>
      <link>https://smartzheng.github.io/posts/navigation%E8%BF%94%E5%9B%9Efragment%E9%87%8D%E8%B5%B0oncreateview%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/navigation%E8%BF%94%E5%9B%9Efragment%E9%87%8D%E8%B5%B0oncreateview%E9%97%AE%E9%A2%98/</guid>
      <description>在使用Navigation的过程中，发现其页面跳转效率确实很不错，XML管理页面跳转逻辑以及fragment之间的参数传递使用起来都很方便，但是一个很大的问题就是在fragment出栈返回上一页时，上一个fragment会重走onCreateView方法。而我们的很多view和数据初始化工作都是在onViewCreated之后进行的，导致的结果是每次回上一个页面可能会重新刷新，这一点体验很差。这里提供一个方法来避免每次重新创建view。
 编写一个BaseNavigationFragment:
class BaseNavigationFragment : BaseFragment() { protected var isNavigationViewInit = false//记录是否已经初始化过一次视图 private var lastView: View? = null//记录上次创建的view override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { //如果fragment的view已经创建则不再重新创建 if (lastView == null) { lastView = super.onCreateView(inflater, container, savedInstanceState) } return lastView } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { if(!isNavigationViewInit){//初始化过视图则不再进行view和data初始化 super.onViewCreated(view, savedInstanceState) initView(view) initData() isNavigationViewInit = true } } }  核心思路在上面的注释，即保存上次创建的view，返回上一页再次走onCreateView时直接将其返回，并且在onViewCreated方法中不再进行初始化工作。
leak canary可能会提示lastView内存泄漏，忽略即可。</description>
    </item>
    
    <item>
      <title>RxJava基本语法源码分析</title>
      <link>https://smartzheng.github.io/posts/rxjava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/rxjava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>最近看了下网上的RxJava源码分析，发现所基于的源码版本和最新的略有不同，于是自己动手翻阅了一下最新的源码版本（rxjava:2.2.8，rxandroid:2.1.1），并写分析博客作分享。
//示例代码 private static void rxJavaTest() { Observable.create(new ObservableOnSubscribe&amp;lt;String&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;String&amp;gt; emitter) { //1 emitter.onNext(&amp;quot;onNext&amp;quot;); emitter.onComplete(); } }).subscribe(new Observer&amp;lt;String&amp;gt;() { @Override public void onSubscribe(Disposable d) { //2 Log.d(TAG, &amp;quot;onSubscribe&amp;quot;); } @Override public void onNext(String s) { //3 Log.d(TAG, s); } @Override public void onError(Throwable e) { //4 Log.d(TAG, &amp;quot;onError&amp;quot;); } @Override public void onComplete() { //5 Log.d(TAG, &amp;quot;onComplete&amp;quot;); } }); }  上面RxJava最简单的使用，主要涉及被观察者Observable、观察者Observer和事件订阅subscribe()三个角色。
首先分析Observable的创建过程，即Observable的create()方法：
public static &amp;lt;T&amp;gt; Observable&amp;lt;T&amp;gt; create(ObservableOnSubscribe&amp;lt;T&amp;gt; source) { ObjectHelper.</description>
    </item>
    
    <item>
      <title>Android启动优化最佳方案：去启动页和异步初始化</title>
      <link>https://smartzheng.github.io/posts/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E6%96%B9%E6%A1%88%E5%8E%BB%E5%90%AF%E5%8A%A8%E9%A1%B5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E6%96%B9%E6%A1%88%E5%8E%BB%E5%90%AF%E5%8A%A8%E9%A1%B5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>项目地址：https://github.com/smartzheng/asyncstarter
随着APP的日渐增大，集成的三方库也越来越多，导致APP的启动极其缓慢。最近在慕课get了一些不错的优化方案，将原来的冷启动时间大概提升30%。 启动的时间监测可以直接用adb命令实现： &amp;gt;adb shell am start -W PackageName/ActivityName
下面是我未优化之前的项目debug版本启动时间（华为p10plus），这里介绍一下几个概念
ThisTime：最后一个Activity启动耗时 TotalTime：所有Activity启动耗时 WaitTimeTime：AMS启动Activity启动耗时
可以看到耗时接近1.3s多（1.3s不算长，但是往往应用加固之后还会慢大一截）。
-&amp;gt; ~ adb shell am start -W com.smartzheng/com.smartzheng.activity.SplashActivity Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category. LAUNCHER]cmp=com.smartzheng/.activity.MainActivity } Warning: Activity not started, its current task has been brought to the front Status: ok Activity: com.uoko.mlgb/.mvp.view.activity.MainActivity ThisTime: 600 TotalTime: 1301 WaitTime: 1330 Complete  优化一：去掉启动页 IPC是个比较耗时的操作，往往我们会设置一个闪屏页，去掉之后可以一定幅度减少启动时间。
我的做法是直接删除SplashActivity，将MainActivity设为启动页。然后在manifests中将其theme设为启动时的theme：
&amp;lt;activity android:name=&amp;quot;.activity.MainActivity&amp;quot; android:configChanges=&amp;quot;screenSize|keyboardHidden|orientation&amp;quot; android:launchMode=&amp;quot;singleTask&amp;quot; android:screenOrientation=&amp;quot;portrait&amp;quot; android:theme=&amp;quot;@style/SplashTheme&amp;quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot;/&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;data android:scheme=&amp;quot;growing.a4ce2f9edf74350a&amp;quot;/&amp;gt; &amp;lt;action android:name=&amp;quot;android.</description>
    </item>
    
    <item>
      <title>伪心理学的本质</title>
      <link>https://smartzheng.github.io/posts/%E4%BC%AA%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/%E4%BC%AA%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
      <description>###1.弗洛伊德问题 一次和人讨论，谈及人生活的目的，对方用马斯洛需求定理给予答复，我回答说：这样的理论实际上来自于总结，并算不上是心理学，或者说作为科学的心理学。他说：那谁的理论比较靠谱呢？我回答：现代心理学属于科学的一种，和哲学不一样，一般而言新结论会推翻旧的结论，所以只需要去看新的研究就行。
弗洛伊德声名远播，却使得公众对心理学产生了很大的误解。他的理论大多来自直觉和经验总结，并不能得到实验的检验。当涉及到数学物理和化学这样的学科时，媒体往往插不上嘴，但是像社会学心理学这样的学科，媒体大众都感觉可以插一句，所以往往被误会过多。从大众对于星座（明确证明为错误的理论）的认知可见一斑。
###2.心理学&amp;ndash;作为科学的分支 现代科学比较重要的几点特征是：（1）采用系统 的实证主义研究方法（2）以可公开验证的知识为研究对象（3）研究实证可解的问题，并产生可检验的理论
中医一直被诟病，导致很多人不信中医乃至批评为迷信。实际上，中医只是在很多疾病治疗上难以证伪（实际上难以证伪并不代表一定无效），也就是不符合科学最重要的一条特征：一个结论，可以通过实验的重复来验证是否正确。宗教不是科学，因为神的存在不可以得到检验。
心理学属于科学的分支，那也应符合这条标准。类似于弗洛伊德的精神分析理论，往往在事后对人的行为进行分析（不无道理，但是很多时候仔细看就像是万金油的解释），并不做事前的预测，所以不可证伪。
###3.本质主义与操作主义 简而言之，本质主义试图找到一切问题的根源，而操作主义只就事论事。前者对应哲学，后者对应科学。
科学家们总是怀疑那些号称找到问题最终答案的言论。科学理论里的概念必须立足于可观测事件，或与可观测事件关联，而这些可观测事件是可以测量的。
比如：对于“焦虑”这个词，心理学不会定义为“我不时会感到不舒服和紧张”，而是会用一些生理指标来衡量。像人生的意义这类价值观问题没有对应的可以衡量的指标，并不是科学的研究范畴。
心理学因为有很多专业用语和公众常用语相同而往往会引起误解。比如“智力”、“焦虑”、“生命”，当心理学中提到这些词语时，都代表的是可以用一些可以观测的指标来衡量的概念。
###4.见证、个案叙述及安慰剂效应 个案叙述：个案并不代表整体，江湖骗术往往得逞，是因为他们总能找到一些运气好恰好治好的病人为他们作证，结论应该建立在大量的重复和统计基础上。假设重病需要做手术的你有两个医生可选择，一个手术成功率为95%，一个为80%，但恰好成功率为95%的一次失败发生在你的一位朋友身上，而他极力建议你不选择他，你会怎样做呢？
见证叙述与安慰剂效应：几乎每种产生于医学和心理学的疗法都要一定数量的支持者。其实这也是中医受人诟病最多的地方，也就是安慰剂效应。实验表明，安慰剂效应发生的概率（没有对症下药，只是让患者这么以为）在抑郁症治疗中是29%，十二指肠溃疡36%，偏头痛29%（患者在服药后感觉病情好转）。所以单单是见证者个人叙述不足以相信（实际操作应该建立对照组，比如一组服用无效的药物，一组服用实验药物，后者有效度高于前者，则证明有效）。
鲜活性问题：实际上飞机失事率远远低于驾车，但是飞机失事的往往更具鲜活性，因为发生的少，一次性死亡人数多，所以媒体也会大加报道，因此人们往往会有飞机不安全的直觉。
###5.相关和因果原则 “外面一定在下雨！”“为什么？”“因为有人打着雨伞。”并不是因为有人打伞才导致的下雨。这是因果的方向性问题。
私立学校的教育水准比公立学校好吗，或者说考上私立学校的学生就比考不上的智力高吗？并不一定，因为选择并有能力读私立学校的人本来家庭就比较富裕，而富裕的人往往教育程度更高，家庭条件，藏书数量等等都高于其他人，所以这些人家里的孩子本来从小受到的教育就要比其他学生好很多。
所以：两个变量之间存在因果现象，并不一定就存在因果关系，可能方向性有问题，也可能含有第三方的变量。
选择性偏差：充满诱惑的相关性证据加上固有的偏见，就能够欺骗最聪明的头脑。美国西部亚利桑那州因呼吸道问题死亡的人最多，是否意味着亚利桑那州的空气最差呢？不是，而是因为患有呼吸道问题的人为了健康考虑有很多人移民到了这里。
###6.控制操作原则 当科学家需要实验时，必须控制可能影响实验的无关变量。常见的做法就是随机分配。
直觉有时候是科学的敌人。研究显示，笃信宗教的人与参加慈善，帮助贫困，或者诚信并没有直接联系。
###7.基础研究与应用型研究 很多人说心理学研究的都是特殊问题，与实际生活联系较少。
咋一看，量子力学似乎与生活毫无关联，但实际上却是息息相关，正是物理学上这种基础性研究改变了世界。这个结论对于心理学同样适用，所以很多看上去与生活无关的心理学问题其实有很大的应用价值。
研究极端，往往可以简化问题，你是否想起高中解数学题时经常假设x=0呢？
###8.爱因斯坦综合征 不少人有一个错觉，认为一个理论的产生往往是翻天覆地式的，就好像爱因斯坦的相对论打破了以为所有的人类认知。实际上，科学的进步往往是共识的达成，那些持着颠覆性言论并宣称发现了世界真理的人往往都是骗子。科学的新理论往往会兼容前面的理论，并且是缓慢前行的。相对论并未否定牛顿定律在地球上宏观世界的实用性。（实际上这一章我并不是很赞同）
###9.多重性原因 A事件是B事件产生的原因，并不代表它是唯一原因。
###10.概率问题 男人往往比女人高，但并不是所有男人都比女人高。这是概率问题，做选择不应借助前面说的个案和见证叙述。
赌徒谬论：如果抛一枚硬币前面九次都是正面朝上，那第十次正面朝上的概率也是1/2。
最终揭示的行为规律，往往是概率关系，而不是绝对的必然预测。让100个人作出两个截然相反的选择，如果根据星座的原理对100个人的性格，对选择的结果进行预测（而不是似是而非的性格描述），并不需要全部正确，只要正确率很高，那星座就是科学的。
###11.偶然性问题 你相信缘分吗？
其实这只是偶合。连续抛十次硬币，全部朝上的概率很小，但是只要重复的次数足够多，那总会发生。人的一生那么长，遇见的人何其多，有一两次你认为是缘分的偶遇有多难呢？
为什么人会存在呢？为什么宇宙会存在呢？或许也只是巧合，毕竟宇宙这么大，宇宙之外呢？
——以上内容来自对《这才是心理学》第十版（基思·斯坦诺维奇）的总结</description>
    </item>
    
    <item>
      <title>ActivityManagerService简析</title>
      <link>https://smartzheng.github.io/posts/activitymanagerservice%E7%AE%80%E6%9E%90/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/activitymanagerservice%E7%AE%80%E6%9E%90/</guid>
      <description>####AMS在Android系统中扮演很重要的角色，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似。当发起进程启动或者组件启动时，都会通过Binder通信机制将请求传递给AMS，AMS再做统一处理。以下以启动Activity为例简析AMS的管理工作。
#####AMS在SystemServer进程中启动，SystemServer的main方法会调用startBootstrapServices方法启动AMS #####7.0及之前，AMS通过代理模式来完成Binder通信： Activity的直接管理者是ActivityManager，但最终管理者是AMS：当Client端发起启动Activity请求后，AM会通过ActivityManagerNative的getDefault来得到其内部类ActivityManagerProxy的单例对象，即AMS在客户端（用户进程）的代理对象，作为代理类，AMP中含有AMS的引用，AMN和AMP都实现了IActivityManager，IActivityManager继承了IInterface（实现Binder通信的必备条件），所以AMP具备了Binder通信能力，statActivity最终会通过AMP中的AMS引用来调用AMS的transact方法，向AMS发送启动Activity请求，并将序列化数据传递给AMS，随后AMS的子类AMN的onTransact会执行，它会将具体的启动工作交给ActivityStater来负责。 具体流程及关系图如下： #####8.0之后，AMS通过AIDL完成Binder通信。具体实现比较简单。
#####ActivityRecord、TaskRecord和ActivityStack AMS中主要涉及这三个数据结构： ActivityRecord：存储Activity的相关信息，比如AndroidMainifes的节点信息，启动Activity的包名，所在进程，图标主题标识符，当前Activity状态，所属TaskRecord等。 TaskRecord：描述一个Activity任务栈，主要维护了一个按历史顺序排列的ArrayList，并包含此任务栈所属的ActivityStack等。 ActivityStack：一个管理系统中所有Activity的管理类，真实交由ActivityStackSupervisor管理，内部维护了Activity的所有状态，并对不同状态的Activity进行分类管理，如最近启动的Activity，正在暂停的Activity等。 #####可以借助下图理解三者关系： </description>
    </item>
    
    <item>
      <title>Android进程启动流程简析</title>
      <link>https://smartzheng.github.io/posts/android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90/</guid>
      <description>自己画了一张简单流程图： 启动一个新进程主要涉及四步： 1、发送启动进程的需求，可能是Launcher启动一个新的APP，或者APP开启独立进程或其他APP
2、发送需求的进程通过Binder通信机制与SystemServer进程通信，通过运行在其中的ActivityManagerService来执行下一步流程
3、AMS通过Socket将创建新进程的请求发送给Zygote进程，在Zygote启动后会执行runSelectLoop方法来等待创建进程请求，当接收到AMS的请求之后fork出新进程，并创建Binder线程池，将新进程的主线程加入到其中，这样新进程也可以使用Binder通信机制了。
4、Zygote进程通过Binder与新开启的应用进程通信，ActivityThread的内部类ApplicationThread作为跨进程通信的桥梁（8.0之后采用AIDL实现，之前使用的是代理模式），ApplicationThread运行在Binder线程中，所以最后需要通过线程切换（H.sendMessage）来进入主线程
###由此可见，一个新进程的创建涉及4个进程，3次跨进程通信，2次为Binder，1次为Sockt</description>
    </item>
    
    <item>
      <title>利用Python实现Android替换内容批量打包</title>
      <link>https://smartzheng.github.io/posts/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0android%E6%9B%BF%E6%8D%A2%E5%86%85%E5%AE%B9%E6%89%B9%E9%87%8F%E6%89%93%E5%8C%85/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0android%E6%9B%BF%E6%8D%A2%E5%86%85%E5%AE%B9%E6%89%B9%E9%87%8F%E6%89%93%E5%8C%85/</guid>
      <description>工作中有一个定制需求：根据不同的用户需求，需要替换APP内的图片，以及部分代码里面的配置信息，打出不同的apk交给客户使用。如果只用生成少量的apk，那么可以将所有图片放入资源文件夹然后根据服务端的信息来进行指定显示，但是随着客户量增加，需要打出数十个apk，并且启动图片不能根据配置来进行替换。所以必须手动更换图片和代码进行打包。这样容易出错，也比较低效，一旦出错必须全部重新返工。所有就写了一个简单的Python脚本来进行一次性批量打包。 GitHub项目地址:https://github.com/smartzheng/AutoApkRelease
 ###安装Python环境内容不再赘述，可参见网上教程。我使用的是Python3。
###以下是详细代码，可参见注释进行配置。
#! python3 # 替换代码和文件，所替换的文本内容必须是当前文件的唯一字符串（可以加长需要替换扥字符串实现唯一性） #如需增加要替换的代码内容或者资源，只需要增加数组并且调用替换方法即可 import os #app启动名 appNames = [&amp;quot;app1&amp;quot;,&amp;quot;app2&amp;quot;,&amp;quot;app3&amp;quot;] #gradle中的applicationId replaceText = [&amp;quot;text1&amp;quot;,&amp;quot;text2&amp;quot;,&amp;quot;text3&amp;quot;] #gradle中的applicationId appIds = [&amp;quot;applicationId1&amp;quot;,&amp;quot;applicationId2&amp;quot;,&amp;quot;applicationId3&amp;quot;] #输出apk的文件名 apkNames = [&amp;quot;apk1&amp;quot;,&amp;quot;apk2&amp;quot;,&amp;quot;apk3&amp;quot;] #项目的资源文件夹路径 targetDir = &amp;quot;/Users/smartzheng/AndroidStudioProjects/MyApplication/app/src/main/res&amp;quot; #配置自己存放不同apk资源图片的路径,分别命名为apk1，apk2，apk3...（apkNames的每个元素）需要替换的图片必须名字对应一致 sourceDir = &amp;quot;/Users/smartzheng/custom_app_imgs/&amp;quot; # 拷贝替换文件，传入图片路径和项目资源目录 def copyFiles(sourceDir, targetDir): for file in os.listdir(sourceDir): sourceFile = os.path.join(sourceDir, file) targetFile = os.path.join(targetDir, file) if os.path.isfile(sourceFile): if not os.path.exists(targetDir): os.makedirs(targetDir) open(targetFile, &amp;quot;wb&amp;quot;).write(open(sourceFile, &amp;quot;rb&amp;quot;).read()) if os.path.isdir(sourceFile): copyFiles(sourceFile, targetFile) #替换文本内容，传入文件路径，原字符串，目标字符串 def replaceText(f_path, text1, text2): with open(f_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as r: s = r.</description>
    </item>
    
    <item>
      <title>利用SpannableString富文本方式设置圆角标签背景</title>
      <link>https://smartzheng.github.io/posts/%E5%88%A9%E7%94%A8spannablestring%E5%AF%8C%E6%96%87%E6%9C%AC%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E6%A0%87%E7%AD%BE%E8%83%8C%E6%99%AF/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/%E5%88%A9%E7%94%A8spannablestring%E5%AF%8C%E6%96%87%E6%9C%AC%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E6%A0%87%E7%AD%BE%E8%83%8C%E6%99%AF/</guid>
      <description>####项目中遇到一个需求,需要在商品标题加上标签,而标签是客户可以后台配置的,所以不是用的图片,而是用的文字.如下图: ####众所周知,在Android中,View都是呈方形布置的,所以如果标签和文字如果不是同一个View,那么如果文字换行,就会出现标签和TextView分别在左右两边的效果: ####经过思考和查阅资料,发现可以用SpannableString设置背景,并通过重写ReplacementSpan替换原来的BackgroundColorSpan来实现圆角标签. ####下面是代码:
Activity: (goodsTags为标签文字集合,即上图的&amp;rdquo;促&amp;rdquo;,&amp;ldquo;九&amp;rdquo;,&amp;ldquo;八&amp;rdquo;&amp;hellip;goodsName为商品名字
for (int i = 0; i &amp;lt; goodsTags.size(); i++) { //为了显示效果在每个标签文字前加两个空格,后面加三个空格(前两个和后两个填充背景,最后一个作标签分割) goodsName.insert(0, &amp;quot; &amp;quot; + goodsTags.get(i).getTags_name() + &amp;quot; &amp;quot;); int start = 0; int end = 5; //稍微设置标签文字小一点 goodsName.setSpan(new RelativeSizeSpan(0.9f), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //设置圆角背景 goodsName.setSpan(new RoundBackgroundColorSpan(Color.parseColor(&amp;quot;#&amp;quot; + goodsTags.get(i).getTags_color()),Color.WHITE), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); }  自定义RoundBackgroundColorSpan:
public class RoundBackgroundColorSpan extends ReplacementSpan { private int bgColor; private int textColor; public RoundBackgroundColorSpan(int bgColor, int textColor) { super(); this.bgColor = bgColor; this.</description>
    </item>
    
    <item>
      <title>bilibili开源库ijkPalyer的集成和使用</title>
      <link>https://smartzheng.github.io/posts/bilibili%E5%BC%80%E6%BA%90%E5%BA%93ijkpalyer%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://smartzheng.github.io/posts/bilibili%E5%BC%80%E6%BA%90%E5%BA%93ijkpalyer%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>最近在我的个人项目中集成了bilibili视频播放库ijkPalyer，网上的很多教程所写的是之前版本的使用方法，官方文档也没有写的太清楚，所以在此做一个简单的介绍。 个人项目：一个基于MVP，dagger2，RXJava，Retrofit，Glide，集成bilibili的ijkPlayer，用Bmob实现后台服务，遵循Material Design风格的APP，数据主要来自豆瓣。欢迎star。 地址：https://github.com/smartzheng/LoveDouBan
1.引入 之前的版本似乎需要进行源码编译，现在直接引入即可。ijkPalyer地址：https://github.com/Bilibili/ijkplayer 最简单的方式，直接在app下的gradle添加：
# required allprojects { repositories { jcenter() } } dependencies { # required, enough for most devices. compile &#39;tv.danmaku.ijk.media:ijkplayer-java:0.8.4&#39; compile &#39;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.4&#39; # Other ABIs: optional compile &#39;tv.danmaku.ijk.media:ijkplayer-armv5:0.8.4&#39; compile &#39;tv.danmaku.ijk.media:ijkplayer-arm64:0.8.4&#39; compile &#39;tv.danmaku.ijk.media:ijkplayer-x86:0.8.4&#39; compile &#39;tv.danmaku.ijk.media:ijkplayer-x86_64:0.8.4&#39; # ExoPlayer as IMediaPlayer: optional, experimental compile &#39;tv.danmaku.ijk.media:ijkplayer-exo:0.8.4&#39; }  如果对源码有兴趣，可以将项目下的以下指出的文件夹（ijkplayer-example可根据需求进行选择，下面会进行介绍）引入到app中： 其中tools直接拷贝，其他文件夹以module的形式引入，再添加为项目依赖即可。
ijkPlayer的定制性比较强，在官方地址下有一个sample，可以将其直接以项目的形式引入至自己的项目中进行使用，其中包括了不少官方写好的工具类和控件。 当然，为了减小apk大小，直接引入一个项目不是好选择，所以我选择复制粘贴需要的代码，如下： 上图中的wiget目录可全部拷贝入自己的项目中，拷贝完成之后会缺少很多资源文件。所以需要再根据报错信息分别将res目录下的相关资源和声明复制到对应的目录或文件中： layout直接拷贝，values复制内容至自己项目对应的values文件中去，并注意删除重复和未使用的声明。
至此，引入完毕。 2.简单使用 1）初始化：官方提供以下两种方式进行初始化操作，在应用初始化或者使用视频播放的activity初始化时调用以下方法。
 //第一：默认初始化 Bmob.initialize(this, &amp;quot;e8f177acd86e0fde391b2af19243fc1b&amp;quot;); // 注:自v3.5.2开始，数据sdk内部缝合了统计sdk，开发者无需额外集成，传渠道参数即可，不传默认没开启数据统计功能 //Bmob.initialize(this, &amp;quot;Your Application ID&amp;quot;,&amp;quot;bmob&amp;quot;); //第二：自v3.4.7版本开始,设置BmobConfig,允许设置请求超时时间、文件分片上传时每片的大小、文件的过期时间(单位为秒)， //BmobConfig config =new BmobConfig.</description>
    </item>
    
  </channel>
</rss>